""" Hybrid-DFT Response-Related Utilities. """
from pyscf.dh.response import RespBase
from pyscf.dh.response.hdft.rhdft import RSCFResp, RHDFTResp
from pyscf.dh.energy.hdft.uhdft import USCF
from pyscf.dh.energy.hdft import UHDFT
from pyscf.dh import util
from pyscf import gto, dft, lib, __config__
import numpy as np


CONFIG_dh_verbose = getattr(__config__, "dh_verbose", lib.logger.NOTE)

α, β = 0, 1
αα, αβ, ββ = 0, 1, 2


def get_eri_cpks_vovo(
        cderi_uaa, mo_occ, cj, ck, eri_cpks_vovo=None,
        max_memory=2000, verbose=CONFIG_dh_verbose):
    r""" Obtain ERI term :math:`A_{ai, bj}^\mathrm{HF}`.

    For given

    Parameters
    ----------
    cderi_uaa : np.ndarray
    mo_occ : np.ndarray
    cj : float
    ck : float
    eri_cpks_vovo : list[np.ndarray] or None
    max_memory : float
    verbose : int

    Returns
    -------
    list[np.ndarray]
    """
    log = lib.logger.new_logger(verbose=verbose)
    time0 = lib.logger.process_clock(), lib.logger.perf_counter()

    # dimension and sanity check
    naux = cderi_uaa[0].shape[0]
    nmo = len(mo_occ[0])
    nocc = (mo_occ != 0).sum(axis=-1)
    nvir = (mo_occ == 0).sum(axis=-1)
    so = [slice(0, nocc[σ]) for σ in (α, β)]
    sv = [slice(nocc[σ], nmo) for σ in (α, β)]
    for σ in α, β:
        assert cderi_uaa[σ].shape == (naux, nmo, nmo)

    # allocate eri_cpks_vovo if necessary
    if eri_cpks_vovo is None:
        eri_cpks_vovo = [np.zeros((nvir[σ], nocc[σ], nvir[ς], nocc[ς])) for (σ, ς) in ((α, α), (α, β), (β, β))]
    else:
        assert len(eri_cpks_vovo) == 3
        for σ, ς, σς in (α, α, αα), (α, β, αβ), (β, β, ββ):
            assert eri_cpks_vovo[σς].shape == (nvir[σ], nocc[σ], nvir[ς], nocc[ς])

    # copy some tensors to memory
    cderi_uvo = [np.asarray(cderi_uaa[σ][:, sv[σ], so[σ]]) for σ in (α, β)]
    cderi_uoo = [np.asarray(cderi_uaa[σ][:, so[σ], so[σ]]) for σ in (α, β)]

    for σ, ς, σς in (α, α, αα), (α, β, αβ), (β, β, ββ):
        log.debug(f"[DEBUG] in get_eri_cpks_vovo, spin {σ, ς}")

        # prepare for async and batch
        mem_avail = max_memory - lib.current_memory()[0]
        nbatch = util.calc_batch_size(max(nvir) * naux + 2 * max(nocc)**2 * max(nvir), mem_avail)

        def load_cderi_uaa(slc):
            return np.asarray(cderi_uaa[σ][:, slc, sv[σ]])

        def write_eri_cpks_vovo(slc, blk):
            eri_cpks_vovo[σς][slc] += blk

        batches = util.gen_batch(nocc[σ], nmo, nbatch)
        with lib.call_in_background(write_eri_cpks_vovo) as async_write_eri_cpks_vovo:
            for sA, cderi_uAa in zip(batches, lib.map_with_prefetch(load_cderi_uaa, batches)):
                log.debug(f"[DEBUG] in get_eri_cpks_vovo, slice {sA} of virtual orbitals {nocc, nmo}")
                sAvir = slice(sA.start - nocc[σ], sA.stop - nocc[σ])
                blk = np.zeros((sA.stop - sA.start, nocc[σ], nvir[ς], nocc[ς]))
                if abs(cj) > 1e-10:
                    blk += 2 * cj * lib.einsum("Pai, Pbj -> aibj", cderi_uvo[σ][:, sAvir], cderi_uvo[ς])
                if abs(ck) > 1e-10 and σ == ς:  # only same spin give k integral
                    blk -= ck * (
                        + lib.einsum("Paj, Pbi -> aibj", cderi_uvo[σ][:, sAvir], cderi_uvo[σ])
                        + lib.einsum("Pij, Pab -> aibj", cderi_uoo[σ], cderi_uAa))
                async_write_eri_cpks_vovo(sAvir, blk)

    log.timer("get_eri_cpks_vovo", *time0)
    return eri_cpks_vovo


def get_Ax0_Core_resp(
        sp, sq, sr, ss, vresp, mo_coeff,
        verbose=CONFIG_dh_verbose):
    r""" Convenient function for evaluation of Fock response in MO basis
    :math:`\sum_{rs} A_{pq, rs} X_{rs}^\mathbb{A}` by PySCF's response function.

    Parameters
    ----------
    sp, sq, sr, ss : list[list or slice]
        Slice of molecular orbital indices.
    vresp : callable
        Fock response function in AO basis (generated by ``mf.scf.gen_response``).
    mo_coeff : np.ndarray
        Molecular orbital coefficients.
    verbose : int
        Print verbosity.

    Returns
    -------
    callable
        A function where input is :math:`X_{rs}^\mathbb{A}`, and output is
        :math:`\sum_{rs} A_{pq, rs} X_{rs}^\mathbb{A}`.

    Notes
    -----
    Convention of our code and pyscf is different. Our code applies 0.5 times on response result from pyscf.
    """
    C = mo_coeff

    def Ax0_Core_resp_inner(X):
        log = lib.logger.new_logger(verbose=verbose)
        time0 = lib.logger.process_clock(), lib.logger.perf_counter()

        assert len(X) == 2
        X_shape = [X[σ].shape for σ in (α, β)]
        X = [X[σ].reshape((-1, X_shape[σ][-2], X_shape[σ][-1])) for σ in (α, β)]
        dmX = np.array([C[σ][:, sr[σ]] @ X[σ] @ C[σ][:, ss[σ]].T for σ in (α, β)])
        dmX += dmX.swapaxes(-1, -2)
        # NOTE: Convention of our code and pyscf is different. 0.5 coefficient is applied here.
        ax_ao = 0.5 * vresp(dmX)
        res = [2 * C[σ][:, sp[σ]].T @ ax_ao[σ] @ C[σ][:, sq[σ]] for σ in (α, β)]
        for σ in α, β:
            res[σ].shape = list(X_shape[σ][:-2]) + [res[σ].shape[-2], res[σ].shape[-1]]

        log.timer("Ax0_Core_resp_inner", *time0)
        return res

    return Ax0_Core_resp_inner


def get_Ax0_cpks_HF(eri_cpks_vovo, max_memory=2000, verbose=CONFIG_dh_verbose):
    r""" Convenient function for evaluation of HF contribution of Fock response in MO basis
    :math:`\sum_{rs} A_{ai, bj} X_{bj}^\mathbb{A}` by explicitly contraction to MO ERI :math:`(ai|bj)`.

    Parameters
    ----------
    eri_cpks_vovo : list[np.ndarray]
    max_memory : float
    verbose : int

    Returns
    -------
    callable
    """
    assert len(eri_cpks_vovo) == 3
    shp = eri_cpks_vovo[αβ].shape
    nocc = shp[1], shp[3]
    nvir = shp[0], shp[2]

    def Ax0_cpks_HF_inner(X):
        log = lib.logger.new_logger(verbose=verbose)
        time0 = lib.logger.process_clock(), lib.logger.perf_counter()

        assert len(X) == 2
        X_shape = [X[σ].shape for σ in (α, β)]
        X = [X[σ].reshape((-1, X_shape[σ][-2], X_shape[σ][-1])) for σ in (α, β)]
        res = [np.zeros_like(X[σ]) for σ in (α, β)]

        for σ, ς, σς in (α, α, αα), (α, β, αβ), (β, β, ββ):

            def load_eri_cpks_vovo(slc):
                return eri_cpks_vovo[σς][slc]

            mem_avail = max_memory - lib.current_memory()[0]
            nbatch = util.calc_batch_size(max(nocc) ** 2 * max(nvir), mem_avail)
            batches = util.gen_batch(0, nvir[σ], nbatch)

            for sA, eri_cpks_Vovo in zip(batches, lib.map_with_prefetch(load_eri_cpks_vovo, batches)):
                if σ == ς:
                    res[σ][:, sA] += lib.einsum("aibj, Abj -> Aai", eri_cpks_Vovo, X[σ])
                else:  # case of αβ
                    res[α][:, sA] += lib.einsum("aibj, Abj -> Aai", eri_cpks_Vovo, X[β])
                    res[β] += lib.einsum("aibj, Aai -> Abj", eri_cpks_Vovo, X[α][:, sA])

        for σ in α, β:
            res[σ].shape = list(X_shape[σ][:-2]) + [res[σ].shape[-2], res[σ].shape[-1]]

        log.timer("Ax0_cpks_HF_inner", *time0)
        return res

    return Ax0_cpks_HF_inner


def get_Ax0_Core_KS(
        sp, sq, sr, ss,
        mo_coeff, xc_setting, xc_kernel,
        max_memory=2000, verbose=CONFIG_dh_verbose):
    r""" Convenient function for evaluation of pure DFT contribution of Fock response in MO basis
    :math:`\sum_{rs} A_{pq, rs} X_{rs}^\mathbb{A}`.

    Parameters
    ----------
    sp, sq, sr, ss : list[slice or list]
    mo_coeff : np.ndarray
    xc_setting : tuple[dft.numint.NumInt, gto.Mole, dft.Grids, str, np.ndarray]
    xc_kernel : tuple[np.ndarray, np.ndarray, np.ndarray]
    max_memory : float
    verbose : int

    Returns
    -------
    callable
    """
    C = mo_coeff
    ni, mol, grids, xc, dm = xc_setting
    rho, _, fxc = xc_kernel

    def Ax0_Core_KS_inner(X):
        log = lib.logger.new_logger(verbose=verbose)
        time0 = lib.logger.process_clock(), lib.logger.perf_counter()
        mem_avail = max_memory - lib.current_memory()[0]

        prop_shape = X[0].shape[:-2]
        X = [X[σ].reshape(-1, X[σ].shape[-2], X[σ].shape[-1]) for σ in (α, β)]
        dmX = np.array([C[σ][:, sr[σ]] @ X[σ] @ C[σ][:, ss[σ]].T for σ in (α, β)])
        dmX += dmX.swapaxes(-1, -2)
        ax_ao = ni.nr_uks_fxc(mol, grids, xc, dm, dmX, hermi=1, rho0=rho, fxc=fxc, max_memory=mem_avail)
        res = [C[σ][:, sp[σ]].T @ ax_ao[σ] @ C[σ][:, sq[σ]] for σ in (α, β)]
        for σ in α, β:
            res[σ].shape = list(prop_shape) + list(res[σ].shape[-2:])

        log.timer("Ax0_Core_KS_inner", *time0)
        return res

    return Ax0_Core_KS_inner


class USCFResp(USCF, RSCFResp):

    def make_cderi_uaa(self, omega=0):
        """ Generate cholesky decomposed ERI (all block, full orbitals, s1 symm, in memory/disk). """
        if util.pad_omega("cderi_uaa", omega) in self.tensors:
            return self.tensors[util.pad_omega("cderi_uaa", omega)]

        log = lib.logger.new_logger(verbose=self.verbose)

        # dimension and mask
        mo_coeff = self.mo_coeff
        nmo = self.nmo

        # density fitting preparation
        with_df = util.get_with_df_omega(self.scf.with_df, omega)
        naux = with_df.get_naoaux()

        # array allocation
        incore_cderi_uaa = self.incore_cderi_uaa
        cderi_uaa = []
        for σ in α, β:
            mem_avail = self.max_memory - lib.current_memory()[0]
            cderi_uaa.append(util.allocate_array(
                incore_cderi_uaa, (naux, nmo, nmo), mem_avail,
                h5file=self._tmpfile, name=util.pad_omega(f"cderi_uaa_{σ}", omega), zero_init=False))
            log.info(f"[INFO] Store type of cderi_uaa (spin {σ}): {type(cderi_uaa)}")

        # generate array
        for σ in α, β:
            util.get_cderi_mo(with_df, mo_coeff[σ], cderi_uaa[σ], max_memory=self.max_memory)

        tensors = {util.pad_omega("cderi_uaa", omega): cderi_uaa}
        self.tensors.update(tensors)
        return cderi_uaa

    def make_eri_cpks_vovo(self):
        r""" Generate ERI for CP-KS evaluation :math:`(ai, bj)` for current exch-corr setting. """
        if "eri_cpks_vovo" in self.tensors:
            return self.tensors["eri_cpks_vovo"]

        # This function will utilize mf.scf._numint to specify hybrid and omega coefficients

        if not hasattr(self.scf, "xc"):
            # not a DFT instance, configure as HF instance
            omega, alpha, hyb = 0, 0, 1
        else:
            ni = self.scf._numint  # type: dft.numint.NumInt
            omega, alpha, hyb = ni.rsh_and_hybrid_coeff(self.scf.xc)

        nvir, nocc = self.nvir, self.nocc
        cderi_uaa = self.tensors.get("cderi_uaa", self.make_cderi_uaa())

        eri_cpks_vovo = []
        for σ, ς, σς in (α, α, αα), (α, β, αβ), (β, β, ββ):
            eri_cpks_vovo.append(util.allocate_array(
                incore=self.incore_eri_cpks_vovo,
                shape=(nvir[σ], nocc[σ], nvir[ς], nocc[ς]),
                max_memory=self.max_memory,
                h5file=self._tmpfile,
                name="eri_cpks_vovo",
                chunk=(1, nocc[σ], nvir[ς], nocc[ς])))

        self.get_eri_cpks_vovo(
            cderi_uaa=cderi_uaa,
            mo_occ=self.mo_occ,
            cj=1, ck=hyb,
            eri_cpks_vovo=eri_cpks_vovo,
            max_memory=self.max_memory,
            verbose=self.verbose
        )

        if abs(omega) > 1e-10:
            cderi_uaa = self.make_cderi_uaa(omega=omega)
            self.get_eri_cpks_vovo(
                cderi_uaa=cderi_uaa,
                mo_occ=self.mo_occ,
                cj=0, ck=alpha-hyb,
                eri_cpks_vovo=eri_cpks_vovo,
                max_memory=self.max_memory,
                verbose=self.verbose
            )

        self.tensors["eri_cpks_vovo"] = eri_cpks_vovo
        return eri_cpks_vovo

    def make_Ax0_cpks(self):
        so, sv = self.mask_occ, self.mask_vir
        ax0_core_ks = self.make_Ax0_Core_KS(sv, so, sv, so)
        ax0_cpks_hf = self.make_Ax0_cpks_HF()

        def Ax0_cpks_inner(X):
            res_hf = ax0_cpks_hf(X)
            res_ks = ax0_core_ks(X)
            if res_ks == 0:
                # case that KS is omitted, then give alpha and beta values
                res_ks = (0, 0)
            res = [res_hf[σ] + res_ks[σ] for σ in (α, β)]
            return res
        return Ax0_cpks_inner

    def make_Ax0_Core(self, sp, sq, sr, ss):
        r""" Convenient function for evaluation of Fock response in MO basis
        :math:`\sum_{rs} A_{pq, rs} X_{rs}^\mathbb{A}`.

        Parameters
        ----------
        sp, sq, sr, ss : list[slice or list]
            Slice of molecular orbital indices.
        """
        # if not RI, then use general Ax0_Core_resp
        if not hasattr(self.scf, "with_df") or not self.use_eri_cpks:
            return self.make_Ax0_Core_resp(sp, sq, sr, ss)

        # try if satisfies CPKS evaluation (vovo)
        lst_nmo = np.arange(self.nmo)
        lst_occ = [lst_nmo[:self.nocc[σ]] for σ in (α, β)]
        lst_vir = [lst_nmo[self.nocc[σ]:] for σ in (α, β)]
        try:
            if (
                    np.all(lst_nmo[sp[α]] == lst_vir[α]) and np.all(lst_nmo[sq[α]] == lst_occ[α]) and
                    np.all(lst_nmo[sr[α]] == lst_vir[α]) and np.all(lst_nmo[ss[α]] == lst_occ[α]) and
                    np.all(lst_nmo[sp[β]] == lst_vir[β]) and np.all(lst_nmo[sq[β]] == lst_occ[β]) and
                    np.all(lst_nmo[sr[β]] == lst_vir[β]) and np.all(lst_nmo[ss[β]] == lst_occ[β])):
                return self.make_Ax0_cpks()
            else:
                # otherwise, use response by PySCF
                return self.make_Ax0_Core_resp(sp, sq, sr, ss)
        except ValueError:
            # dimension not match
            return self.make_Ax0_Core_resp(sp, sq, sr, ss)

    def make_lag_vo(self):
        return 0, 0

    def make_rdm1_resp(self, ao_repr=False):
        r""" Generate 1-RDM (response) of hybrid DFT :math:`D_{pq}` in MO or :math:`D_{\mu \nu}` in AO. """
        nmo = self.nmo
        rdm1 = np.zeros((2, nmo, nmo))
        for σ in α, β:
            rdm1[σ] = np.diag(self.mo_occ[σ])
        self.tensors["rdm1_resp"] = rdm1
        if ao_repr:
            rdm1 = lib.einsum("sup, spq, svq -> suv", self.mo_coeff, rdm1, self.mo_coeff)
        return rdm1

    get_Ax0_Core_resp = staticmethod(get_Ax0_Core_resp)
    get_eri_cpks_vovo = staticmethod(get_eri_cpks_vovo)
    get_Ax0_cpks_HF = staticmethod(get_Ax0_cpks_HF)
    get_Ax0_Core_KS = staticmethod(get_Ax0_Core_KS)


class UHDFTResp(UHDFT, USCFResp):

    def make_lag_vo(self):
        r""" Generate hybrid DFT contribution to Lagrangian vir-occ block :math:`L_{ai}`. """
        if "lag_vo" in self.tensors:
            return self.tensors["lag_vo"]

        so, sv = self.mask_occ, self.mask_vir
        mo_coeff = self.mo_coeff
        lag_vo = []
        fock_ao = self.hdft.get_fock(dm=self.scf.make_rdm1())
        for σ in (α, β):
            lag_vo.append(2 * mo_coeff[σ][:, sv[σ]].T @ fock_ao[σ] @ mo_coeff[σ][:, so[σ]])
        self.tensors["lag_vo"] = lag_vo
        return lag_vo

    def make_rdm1_resp(self, ao_repr=False):
        r""" Generate 1-RDM (response) of hybrid DFT :math:`D_{pq}` in MO or :math:`D_{\mu \nu}` in AO. """

        nocc, nmo = self.nocc, self.nmo
        so, sv = self.mask_occ, self.mask_vir
        rdm1 = np.zeros((2, nmo, nmo))
        make_rdm1_resp_vo = self.make_rdm1_resp_vo()
        for σ in α, β:
            rdm1[σ] = np.diag(self.mo_occ[σ])
            rdm1[σ][np.ix_(sv[σ], so[σ])] = make_rdm1_resp_vo[σ]
        self.tensors["rdm1_resp"] = rdm1
        if ao_repr:
            rdm1 = lib.einsum("sup, spq, svq -> suv", self.mo_coeff, rdm1, self.mo_coeff)
        return rdm1

    make_rdm1_resp_vo = RHDFTResp.make_rdm1_resp_vo
    scf_resp = RespBase.scf_resp
    Ax0_Core = RespBase.Ax0_Core


if __name__ == '__main__':

    def main_1():
        from pyscf import gto, scf, dft
        np.set_printoptions(10, suppress=True, linewidth=150)
        mol = gto.Mole(atom="O; H 1 0.94; H 1 0.94 2 104.5", basis="6-31G", charge=1, spin=1).build()

        mf = dft.UKS(mol, xc="B3LYP").density_fit("cc-pVDZ-jkfit").run(conv_tol=1e-12)
        mf_hdft = UHDFTResp(mf, xc="CAM-B3LYP")
        dip_anal = mf_hdft.make_dipole()

        # generation of numerical result

        def eng_with_dipole_field(t, h):
            mf_scf = dft.UKS(mol, xc="B3LYP").density_fit("cc-pVDZ-jkfit")
            mf_scf.get_hcore = lambda *args, **kwargs: scf.hf.get_hcore(mol) - h * mol.intor("int1e_r")[t]
            mf_scf.run(conv_tol=1e-12)
            mf_mp = UHDFTResp(mf_scf, xc="CAM-B3LYP").run()
            return mf_mp.e_tot

        eng_array = np.zeros((2, 3))
        h = 1e-4
        for idx, h in [(0, h), [1, -h]]:
            for t in (0, 1, 2):
                eng_array[idx, t] = eng_with_dipole_field(t, h)
        dip_elec_num = - (eng_array[0] - eng_array[1]) / (2 * h)
        dip_nuc = np.einsum("A, At -> t", mol.atom_charges(), mol.atom_coords())
        dip_num = dip_elec_num + dip_nuc

        print(dip_num)
        print(dip_anal)

    main_1()
